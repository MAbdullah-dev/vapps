import { NextRequest, NextResponse } from "next/server";
import { getRequestContext } from "@/lib/request-context";
import { queryTenant, getTenantPool } from "@/lib/db/tenant-pool";
import { cache, cacheKeys } from "@/lib/cache";
import crypto from "crypto";

/**
 * GET /api/organization/[orgId]/processes?siteId=xxx
 * Get all processes for an organization, optionally filtered by siteId
 */
export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ orgId: string }> }
) {
  try {
    const { orgId } = await params;
    const { searchParams } = new URL(req.url);
    const siteId = searchParams.get("siteId");

    // Get request context (user + tenant) - single call, cached
    const ctx = await getRequestContext(req, orgId);
    if (!ctx) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Check cache first (60s TTL)
    const cacheKey = cacheKeys.orgProcesses(orgId, siteId || undefined);
    const cached = cache.get<{ processes: any[] }>(cacheKey);
    if (cached) {
      return NextResponse.json(cached);
    }

    try {
      // OPTIMIZED: Single query with JOIN using pooled connection
      const processesQuery = siteId
        ? `
          SELECT 
            p.id,
            p.name,
            p.description,
            p."siteId",
            p."createdAt",
            p."updatedAt",
            s.name as "siteName",
            s.code as "siteCode",
            s.location as "siteLocation"
          FROM processes p
          INNER JOIN sites s ON p."siteId" = s.id
          WHERE p."siteId" = $1
          ORDER BY p."createdAt" DESC
        `
        : `
          SELECT 
            p.id,
            p.name,
            p.description,
            p."siteId",
            p."createdAt",
            p."updatedAt",
            s.name as "siteName",
            s.code as "siteCode",
            s.location as "siteLocation"
          FROM processes p
          INNER JOIN sites s ON p."siteId" = s.id
          ORDER BY p."createdAt" DESC
        `;

      const processes = await queryTenant<any>(orgId, processesQuery, siteId ? [siteId] : undefined);

      const response = { processes };

      // Cache the response for 60 seconds
      cache.set(cacheKey, response, 60 * 1000);

      return NextResponse.json(response);
    } catch (dbError: any) {
      return NextResponse.json(
        { error: "Failed to fetch processes", message: dbError.message },
        { status: 500 }
      );
    }
  } catch (error: any) {
    console.error("Error fetching processes:", error);
    return NextResponse.json(
      { error: "Internal server error", message: error.message },
      { status: 500 }
    );
  }
}

/**
 * POST /api/organization/[orgId]/processes
 * Create a new process for a site
 */
export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ orgId: string }> }
) {
  try {
    const { orgId } = await params;
    const body = await req.json();
    const { name, description, siteId } = body;

    // Get request context (user + tenant) - single call, cached
    const ctx = await getRequestContext(req, orgId);
    if (!ctx) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (!name || !name.trim()) {
      return NextResponse.json(
        { error: "Process name is required" },
        { status: 400 }
      );
    }

    if (!siteId) {
      return NextResponse.json(
        { error: "Site ID is required" },
        { status: 400 }
      );
    }

    try {
      // Use pooled connection
      const pool = await getTenantPool(orgId);
      const client = await pool.connect();

      try {
        // Verify site exists
        const siteResult = await client.query(
          `SELECT id, name FROM sites WHERE id = $1`,
          [siteId]
        );

        if (siteResult.rows.length === 0) {
          return NextResponse.json(
            { error: "Site not found" },
            { status: 404 }
          );
        }

        // Insert new process
        const processId = crypto.randomUUID();
        await client.query(
          `INSERT INTO processes (id, name, description, "siteId", "createdAt", "updatedAt")
           VALUES ($1, $2, $3, $4, NOW(), NOW())`,
          [processId, name.trim(), description?.trim() || null, siteId]
        );

        // Fetch the created process with site information
        const processResult = await client.query(
          `SELECT 
            p.id,
            p.name,
            p.description,
            p."siteId",
            p."createdAt",
            p."updatedAt",
            s.name as "siteName",
            s.code as "siteCode",
            s.location as "siteLocation"
          FROM processes p
          INNER JOIN sites s ON p."siteId" = s.id
          WHERE p.id = $1`,
          [processId]
        );

        // Clear cache after mutation
        cache.delete(cacheKeys.orgProcesses(orgId));
        cache.delete(cacheKeys.orgProcesses(orgId, siteId));
        cache.delete(cacheKeys.orgSites(orgId));

        return NextResponse.json(
          {
            message: "Process created successfully",
            process: processResult.rows[0],
          },
          { status: 201 }
        );
      } finally {
        client.release(); // CRITICAL: Always release connection back to pool
      }
    } catch (dbError: any) {
      return NextResponse.json(
        { error: "Failed to create process", message: dbError.message },
        { status: 500 }
      );
    }
  } catch (error: any) {
    console.error("Error creating process:", error);
    return NextResponse.json(
      { error: "Internal server error", message: error.message },
      { status: 500 }
    );
  }
}
